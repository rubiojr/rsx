# Risor Language Reference Guide

## Core Syntax

### Variable Declaration
```risor
// Use := for variable declaration (not var keyword like in Go)
x := 10
y := "hello"
z := 3.14

// Constants
const URL = "https://example.com"

// Multiple variables need container initialization
a, b, c := [1, 2, 3]  // Not a = b = c = value
```

### Data Types
```risor
// Basic types
num := 42          // int
price := 19.99     // float
name := "Alice"    // string
active := true     // bool
nothing := nil     // nil

// Container types
items := [1, 2, 3]           // list
settings := {theme: "dark"}  // map (keys are always strings)
uniqueIds := {1, 2, 3}       // set
```

### String Handling
```risor
// Three types of strings:
standard := "Double quotes: standard strings"
template := 'Single quotes: support {variable} interpolation'
multiline := `Backticks: raw strings
that span multiple
lines`

name := "world"
greeting := 'Hello, {name}!'  // "Hello, world!"

// String methods
"hello".to_upper()            // "HELLO"
"  text  ".trim_space()       // "text"
"a,b,c".split(",")            // ["a", "b", "c"]
",".join(["a", "b", "c"])     // "a,b,c"
```

### Functions
```risor
// Basic function
func add(a, b) {
  return a + b
}

// Function with default parameter
func greet(name='world') {
  return 'Hello, {name}!'
}

// Functions as values
doubler := func(x) {
  return x * 2
}

// Functions can only return a single value
// Use containers for multiple return values
func get_user_info() {
  return {name: "Alice", age: 30}
}

// Unpacking
info := get_user_info()
print(info.name)
```

### Control Flow
```risor
// If-else as expression
status := if x > 10 {
  "greater"
} else if x == 10 {
  "equal"
} else {
  "lesser"
}

// Switch as expression
role := switch name {
  case "admin":
    "Administrator"
  case "mod":
    "Moderator"
  default:
    "User"
}

// Loops
for i := 0; i < 5; i++ {
  print(i)
}

for i := range 5 {
  print(i)
}

i := 0
for i < 5 {
  print(i)
  i++
}

list := [1, 2, 3]
for i, value := range list {
  print(i, value)
}

// Ternary expression
allowed := age >= 18 ? true : false
```

## Error Handling

```risor
// Raising errors
func divide(a, b) {
  if b == 0 {
    error("division by zero")
  }
  return a / b
}

// Try function for error handling
result := try(
  func() {
    return divide(10, 0)
  },
  "division failed"
)  // result is "division failed"

// Chaining fallbacks
result := try(
  func() { error("first error") },
  func() { error("second error") },
  "default value"
)  // result is "default value"

// Access the error in fallback
result := try(
  func() {
    error("something failed")
  },
  func(err) {
    print("Error caught:", err)
    return "recovered"
  }
)
```

## Pipe Operator

```risor
// Pipe operator passes the left value as first argument to the right function
"hello" | strings.to_upper                 // "HELLO"
[1, 2, 3] | math.sum                       // 6

// Chain pipes
"  hello  " | strings.trim_space | strings.to_upper  // "HELLO"

// Process data pipeline style
fetch("https://api.example.com/users")
  | .json()
  | jmespath("[].name")
```

## Modules and Imports

```risor
// Import module (no quotes)
import math
import time

// Import with alias
import strings as str

// Import specific attributes
from os import read_file, write_file

// Using imported modules
math.sqrt(16)
str.to_upper("hello")
```

## Concurrency

```risor
// Channels
c := chan(1)    // Buffered channel with capacity 1
c <- "hello"    // Send value
x := <-c        // Receive value
close(c)        // Close channel

// Range over channel (different from Go)
for i, value := range c {
  print(i, value)  // i is the index
}

// Goroutines
go func() {
  // Run in background
  time.sleep(1)
  print("background task completed")
}()

// Spawn and wait for result
result := spawn(func(x) {
  time.sleep(1)
  return x * 2
}, 21).wait()   // result is 42
```

## Built-ins and Common Modules

### Key Built-ins
```risor
print("Output to console")           // Print to stdout
len([1, 2, 3])                       // Length of container (3)
assert(x > 0, "must be positive")    // Assertion with message
type([1, 2])                         // Returns "list"
keys({a: 1, b: 2})                   // Returns ["a", "b"]
```

### HTTP Operations
```risor
// Simple HTTP request
response := fetch("https://api.example.com")
status := response.status_code  // e.g., 200
data := response.json()         // Parse JSON response

// Request with options
response := fetch("https://api.example.com", {
  method: "POST",
  headers: {"Content-Type": "application/json"},
  data: {name: "Alice", age: 30}
})
```

### File Operations
```risor
// Read/write files
content := os.read_file("config.json")
os.write_file("output.txt", "Hello, world!")

// Directory operations
files := os.read_dir("/tmp")
os.mkdir("new_directory", 0755)
path := filepath.join("path", "to", "file.txt")
```

### JSON and YAML
```risor
// JSON operations
json_str := json.marshal({name: "Alice", age: 30})
obj := json.unmarshal('{"name": "Bob", "age": 25}')

// YAML operations
yaml_str := yaml.marshal({name: "Alice", age: 30})
obj := yaml.unmarshal("name: Bob\nage: 25")
```

### Time and Date
```risor
// Time operations
now := time.now()
formatted := now.format(time.RFC3339)
time.sleep(0.5)  // Sleep for 0.5 seconds
```

## Complete Examples

### HTTP API Client
```risor
import os

// Function to fetch user data
func get_user(id) {
  response := try(
    func() {
      return fetch('https://api.example.com/users/{id}')
    },
    func(err) {
      print("Request failed:", err)
      return nil
    }
  )

  if response == nil {
    return nil
  }

  if response.status_code != 200 {
    print("Error:", response.status_code)
    return nil
  }

  return response.json()
}

// Process and save user data
user := get_user(42)
if user != nil {
  print('Found user: {user.name}')
  os.write_file("user_data.json", json.marshal(user))
}
```

### Concurrent File Processing
```risor
import os
import filepath

func process_file(path) {
  content := try(
    func() { return os.read_file(path) },
    func(err) {
      print('Error reading {path}:', err)
      return nil
    }
  )

  if content == nil {
    return nil
  }

  // Process content (e.g., count lines)
  lines := strings.split(string(content), "\n")
  return len(lines)
}

// Process multiple files concurrently
files := os.read_dir(".")
threads := []

for _, file := range files {
  if filepath.ext(file.name) == ".txt" {
    threads.append(spawn(process_file, file.name))
  }
}

// Collect results
results := {}
for i, thread := range threads {
  path := files[i].name
  results[path] = thread.wait()
}

print("Results:", results)
# Important rules when writing Risor code
- Use two spaces to indent code
- No `var` keyword for variables (use `:=`)
- No `??` operator for null coalescing (use `coalesce()` function)
- Module imports don't use quotes. Use `import math` and not not `import "math"`
- Use single quotes for string interpolation: `'Hello, {name}'`
- If-else and switch are expressions that return values
- String interpolation with single quotes only supports simple variable substitution (`'{variable}'`). It does not support formatting specifications inside the curly braces like Python's f-strings. To format values, use the `fmt.sprintf()` function separately and concatenate the results
- ^ is not a valid power operator in Risor. Use math.pow() function instead
- Use os.stdin.input() to read input from the user

Always follow the above rules.
# Errors Module Summary
Errors module provides functions for creating error values in Risor.
## Functions
* new(string) - Creates a new error value with the given message

# Exec Module Summary
Exec module is used to run external commands without invoking the system shell.
## Functions
* exec(args, opts) - Runs command and returns result object
* command(args) - Creates a new command
* look_path(name) - Searches for executable in PATH
## Types
* command - Has path, dir, env, stdout, stderr attributes and run(), output(), combined_output(), start(), wait() methods
* result - Has stdout, stderr, pid attributes

# Filepath Module Summary
Filepath module provides utilities to manipulate file paths with OS-specific separators.
## Functions
* abs(path) - Returns absolute representation of path
* base(path) - Returns last element of path
* clean(path) - Returns shortest path name equivalent
* dir(path) - Returns all but last element of path
* ext(path) - Returns file extension
* is_abs(path) - Checks if path is absolute
* join(paths...) - Joins path elements with OS-specific separator
* match(pattern, name) - Checks if filename matches shell pattern
* rel(basepath, targpath) - Returns relative path from base to target
* split_list(path) - Splits path into directory and file components as list
* split(path) - Splits path into directory and file components
* walk_dir(root, fn) - Walks file tree calling function for each entry
# HTTP Module Summary
HTTP module provides functions for making HTTP requests and handling responses.
## Functions
* get(url, headers, params) - Creates a GET request
* delete(url, headers, params) - Creates a DELETE request
* head(url, headers, params) - Creates a HEAD request
* listen_and_serve(addr, handler) - Starts an HTTP server
* listen_and_serve_tls(addr, cert_file, key_file, handler) - Starts an HTTPS server
* patch(url, headers, body) - Creates a PATCH request
* post(url, headers, body) - Creates a POST request
* put(url, headers, body) - Creates a PUT request
* request(url, options) - Creates a custom HTTP request
## Types
* request - Has url, content_length, header attributes and send(), add_header(), add_cookie(), set_body(), set_data() methods
* response - Has status, status_code, proto, content_length, header, cookies, response attributes and json(), text(), close() methods
* response_writer - Has add_header(), del_header(), write(), write_header() methods
# Math Module Summary
Math module provides constants and mathematical functions, wrapping Go's math package with additional utilities.
## Constants
* PI - Mathematical constant pi (3.141592653589793)
* E - Mathematical constant e (2.718281828459045)
## Functions
* abs(x) - Returns absolute value
* sqrt(x) - Returns square root
* min(x, y) - Returns smaller of two numbers
* max(x, y) - Returns larger of two numbers
* floor(x) - Returns largest integer less than or equal to x
* ceil(x) - Returns smallest integer greater than or equal to x
* sin(x) - Returns sine
* cos(x) - Returns cosine
* tan(x) - Returns tangent
* mod(x, y) - Returns remainder of division
* log(x) - Returns natural logarithm
* log10(x) - Returns base-10 logarithm
* log2(x) - Returns base-2 logarithm
* pow(x, y) - Returns x raised to power of y
* pow10(x) - Returns 10 raised to power of x
* is_inf(x) - Checks if value is infinity
* inf() - Returns infinite value
* round(x) - Rounds to nearest integer
* sum(list) - Returns sum of all numbers in list
# OS Module Summary
OS module provides platform-independent access to operating system functionality.
## Attributes
* stdin - Standard input file pointer
* stdout - Standard output file pointer
## Functions
* chdir(dir) - Changes working directory
* create(name) - Creates or truncates a file
* environ() - Returns environment variables as list of strings
* exit(code) - Terminates program with exit code
* getenv(key) - Gets environment variable value
* getpid() - Returns current process ID
* getuid() - Returns current user ID
* getwd() - Gets current working directory
* hostname() - Returns system hostname
* mkdir_all(path, perm) - Creates directory with parents
* mkdir_temp(dir, prefix) - Creates temporary directory
* mkdir(path, perm) - Creates directory
* open(name) - Opens file for reading
* read_dir(name) - Lists directory contents
* read_file(name) - Reads file contents
* remove(name) - Removes file or empty directory
* remove_all(name) - Removes directory and contents
* rename(old, new) - Renames/moves file or directory
* setenv(key, value) - Sets environment variable
* stat(name) - Returns file information
* symlink(old, new) - Creates symbolic link
* temp_dir() - Returns temporary directory path
* unsetenv(key) - Unsets environment variable
* user_cache_dir() - Returns user cache directory
* user_config_dir() - Returns user config directory
* user_home_dir() - Returns user home directory
* write_file(name, data) - Writes data to file
## Types
* File - Has read(), write(), close() methods
* FileInfo - Contains name, mode, size, mod_time attributes
* DirEntry - Contains name, type attributes
# regexp Module Summary
The regexp module provides regular expression matching functionality using Go's regexp syntax.
## Functions
- `compile(expr string)` - Compiles a regular expression string
- `match(expr, s string)` - Tests if a string contains a pattern match
## Types
- `regexp` - Represents a compiled regular expression
- `match(s string)` - Tests if string contains pattern match
- `find(s string)` - Returns leftmost match
- `find_all(s string)` - Returns all matches
- `find_submatch(s string)` - Returns matches and submatches
- `replace_all(s, repl string)` - Replaces all matches with replacement
- `split(s string)` - Splits string by pattern matches
# Strings Module Summary
String manipulation functions from the Go standard library.
## Functions
* compare(s1, s2) - Compares strings lexicographically
* contains(s, substr) - Checks if string contains substring
* count(s, substr) - Counts non-overlapping instances of substring
* fields(s) - Splits string on whitespace
* has_prefix(s, prefix) - Checks if string starts with prefix
* has_suffix(s, suffix) - Checks if string ends with suffix
* index(s, substr) - Returns first index of substring or -1
* join(a, sep) - Concatenates strings with separator
* last_index(s, substr) - Returns last index of substring or -1
* repeat(s, count) - Creates new string with repeated copies
* replace_all(s, old, new) - Replaces all instances of old with new
* split(s, sep) - Splits string on separator
* to_lower(s) - Converts string to lowercase
* to_upper(s) - Converts string to uppercase
* trim_prefix(s, prefix) - Removes leading prefix if present
* trim_space(s) - Removes leading and trailing whitespace
* trim_suffix(s, suffix) - Removes trailing suffix if present
* trim(s, cutset) - Removes leading and trailing characters in cutset
# Time Module Summary
Time module provides functionality for measuring and displaying time.
## Constants
* ANSIC, UnixDate, RubyDate, RFC822, RFC822Z, RFC850, RFC1123, RFC1123Z, RFC3339, RFC3339Nano, Kitchen, Stamp, StampMilli, StampMicro, StampNano - Predefined date/time formats
## Functions
* now() - Returns current time
* unix(sec, nsec) - Returns time from Unix timestamp
* parse(layout, value) - Parses string into time object
* since(t) - Returns seconds elapsed since given time
* sleep(duration) - Pauses execution for specified seconds
## Types
* time - Has before(t), after(t), format(layout), utc(), unix() methods
